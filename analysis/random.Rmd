---
title: "Overview"
---

Setup.

```{r setup}
knitr::opts_chunk$set(echo = TRUE, collapse = TRUE)
knitr::opts_knit$set(root.dir = "~/Saez/report")
```

Loaded packages.

```{r}
suppressPackageStartupMessages(library(mistyR))
suppressPackageStartupMessages(library(future))
suppressPackageStartupMessages(library(tidyverse))
plan("multisession", workers=14)
```

# Appendix

```{r}
data("synthetic")
expr <- synthetic$synthetic1 %>% select(-c(row, col, type))
pos <- synthetic$synthetic1 %>% select(c(row, col))
misty.views <- create_initial_view(expr) %>%
  add_paraview(positions = pos, l = 12, zoi = 0)
```


## What effect do the approximations have on the predictive performance?

The possibility for subsampling the training set was introduced to 
reduce the training time, since MISTy is often applied to large
datasets where the modelling of each view should not take too long.

Since the approximation only affects the computation of the unbiased 
prediction, we only need to have a look at the performance estimation

### SVM

```{r}
approx.results.svm <- map(seq(0.1, 1, l = 10), function(frac) {
  print(frac)
  misty.views %>%
  run_misty(model.function = svm_model, approx = TRUE, approx.frac = frac) %>%
  collect_results()
})
```

I guess based on those results a default approximation fraction of **0.4** would 
make sense.

```{r fig.height=6, fig.width=12}
svm.improvements <- map2_dfr(approx.results.svm, 
                             seq(0.1, 1, l = 10), function(misty.results, frac) {
  misty.results$improvements %>% mutate(approx.frac = frac)
})
svm.improvements %>%
  mutate(approx.frac = factor(approx.frac, levels = seq(0.1, 1, l = 10))) %>%
  filter(measure == "multi.R2") %>%
  ggplot() +
  geom_point(aes(x = approx.frac, y = value)) +
  facet_wrap(~ target, scales="free")
```

### NN

```{r}
approc.results.nn <- map(seq(0.1, 1, l = 10), function(frac) {
  print(frac)
  misty.views %>%
  run_misty(model.function = mlp_model, approx = TRUE, approx.frac = frac) %>%
  collect_results()
})
```

I guess based on those results a default approximation fraction of **0.6** would 
make sense.

```{r fig.height=6, fig.width=12}
nn.improvements <- map2_dfr(approc.results.nn, 
                             seq(0.1, 1, l = 10), function(misty.results, frac) {
  misty.results$improvements %>% mutate(approx.frac = frac)
})
nn.improvements %>%
  mutate(approx.frac = factor(approx.frac, levels = seq(0.1, 1, l = 10))) %>%
  filter(measure == "multi.R2") %>%
  ggplot() +
  geom_point(aes(x = approx.frac, y = value)) +
  facet_wrap(~ target, scales="free")
```

## Overfitting the NN Function

```{r}
sizes = list("5" = c(5), "10" = c(10), "2x10" = c(10, 10), "3x10" = c(10, 10, 10),
             "3x16" = c(16, 16, 16))
overfit.nn.results <- map(sizes, function(s) {
  print(s)
  misty.views %>%
  run_misty(model.function = mlp_model, approx = TRUE, approx.frac = 0.6,
            size = s) %>%
  collect_results()
})
```

And we basically see that the landscape is highly heterogeneous depending
on the target. Sometimes a more complex model is helpful and sometimes not! 

```{r fig.height=6, fig.width=12}
overfit.nn.impro <- map2_dfr(overfit.nn.results, 
                             names(sizes), function(misty.results, s) {
  misty.results$improvements %>% mutate(size = s)
})
overfit.nn.impro %>%
  filter(measure == "multi.R2") %>%
  mutate(size = factor(size, levels = names(sizes))) %>%
  ggplot() +
  geom_point(aes(x = size, y = value)) +
  facet_wrap(~ target, scales="free")
```

## Which Hyperparameters to consider for bagged mars?

```{r}
mars1 <- run_misty(misty.views, model.function = bagged_mars_model, 
                   n.bags = 50, degree = 1, penalty = 2) %>%
  collect_results()

mars2 <- run_misty(misty.views, model.function = bagged_mars_model, 
                   n.bags = 50, degree = 2, penalty = 3) %>%
  collect_results()

mars3 <- run_misty(misty.views, model.function = bagged_mars_model, 
                   n.bags = 50, degree = 2, penalty = 3, 
                   pmethod = "none", fast.k = 20) %>%
  collect_results()

mars4 <- run_misty(misty.views, model.function = bagged_mars_model, 
                   n.bags = 50, degree = 2, penalty = 3,
                   pmethod = "none", fast.k = 5) %>%
  collect_results()

results <- list(mars1, mars2, mars3, mars4)
mars.test.perf <- map2_dfr(results, seq_len(length(results)),
                           function(res, i) { res$improvements %>%
                             mutate(parameters = i) })
mars.test.perf %>%
    filter(measure == "multi.R2") %>%
    mutate(parameters = factor(parameters, 
                               levels = seq_len(length(results))), 
                               sample = NULL, measure = NULL) %>%
  ggplot() +
  geom_point(aes(x = target, y = value, col = parameters))
```

## Run Times

```{r}
functions <- c("RF" = random_forest_model, "BOOST" = gradient_boosting_model, 
               "MARS" = mars_model, "BGMARS" = bagged_mars_model,
               "LM" = linear_model, "SVM" = svm_model,
               "MLP" = mlp_model)
```

```{r}
timing <- map2_dfr(functions, names(functions), function(fun, fun.name) {
  start <- Sys.time()
  misty.views %>% run_misty(model.function = fun, results.folder = "results")
  end <- Sys.time()
  tibble::tibble(model.function = fun.name, time = (end - start))
})
rf <- timing %>% filter(model.function == "RF") %>% pull(time) %>% as.numeric
timing %>%
  arrange(desc(time)) %>% 
  mutate(rel.to.rf = round(as.numeric(time) / rf, 2))
```

```{r eval=FALSE, include=FALSE}
misty.views.smp <- map(synthetic, function(smp) {
  expr <- smp %>% select(-c(row, col, type))
  pos <- smp %>% select(c(row, col))
  misty.views <- create_initial_view(expr) %>%
    add_paraview(positions = pos, l = 10)
})

timing <- map2_dfr(functions, names(functions), function(fun, fun.name) {
  start <- Sys.time()
  misty.results.string <- map_chr(misty.views.smp, function(ms) {
    ms %>% run_misty(model.function = fun, results.folder = "results")
  })
  end <- Sys.time()
  tibble::tibble(model.function = fun.name, time = (end - start))
})
rf <- timing %>% filter(model.function == "RF") %>% pull(time) %>% as.numeric
timing %>%
  arrange(desc(time)) %>% 
  mutate(rel.to.rf = round(as.numeric(time) / rf, 2))
```

```{r echo=FALSE}
unlink("results", recursive = TRUE)
```


## Hyperparameters

### Interaction Terms MARS

degree: The maximum degree of interaction. Default is 1, 
use 2 for first-order interactions of the hinge functions.

First-order interaction mean products of hinge function without squaring
any thing, e.g. $f(x) = ax_1 + bx_2 + cx_1x_2 + d$.

From “Notes on the earth package”:

"For interaction terms, each variable gets credit for the entire term — thus
interaction terms are counted more than once and get a total higher weighting 
than additive terms (questionably). Each variable gets equal credit in interaction
terms even though one variable in that term may be far more important than the
other."

```{r}
degrees <- seq.int(1, 4)
deg.test <- map(degrees, function(n) {
  misty.views %>%
    run_misty(model.function = bagged_mars_model, degree = n) %>%
    collect_results()
})
deg.test.performance <- map2_dfr(deg.test, degrees, 
                            ~ .x$improvements %>% mutate(degree = .y))
```

Adding interactions terms improves the performance of MARS a lot! But does
this go at the cost of reducing the interpretability (see the above note).

However, I think it may be smart to change the default degree to 2.

```{r}
deg.test.performance %>%
  filter(measure == "multi.R2") %>%
  mutate(degree = factor(degree, levels = degrees), 
         sample = NULL, measure = NULL) %>%
  ggplot() +
  geom_point(aes(x = target, y = value, col = degree))
```
